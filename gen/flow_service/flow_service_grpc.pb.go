// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: flow_service/flow_service.proto

package flow_service

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Flow_InboxDelete_FullMethodName      = "/kontrl.Flow/InboxDelete"
	Flow_InboxFind_FullMethodName        = "/kontrl.Flow/InboxFind"
	Flow_InboxGet_FullMethodName         = "/kontrl.Flow/InboxGet"
	Flow_InboxRegister_FullMethodName    = "/kontrl.Flow/InboxRegister"
	Flow_OutboxDelete_FullMethodName     = "/kontrl.Flow/OutboxDelete"
	Flow_OutboxFind_FullMethodName       = "/kontrl.Flow/OutboxFind"
	Flow_OutboxGet_FullMethodName        = "/kontrl.Flow/OutboxGet"
	Flow_OutboxRegister_FullMethodName   = "/kontrl.Flow/OutboxRegister"
	Flow_ResponseDelete_FullMethodName   = "/kontrl.Flow/ResponseDelete"
	Flow_ResponseRegister_FullMethodName = "/kontrl.Flow/ResponseRegister"
	Flow_TargetDelete_FullMethodName     = "/kontrl.Flow/TargetDelete"
	Flow_TargetRegister_FullMethodName   = "/kontrl.Flow/TargetRegister"
)

// FlowClient is the client API for Flow service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FlowClient interface {
	InboxDelete(ctx context.Context, in *MsgDeleteIn, opts ...grpc.CallOption) (*MsgDeleteOut, error)
	InboxFind(ctx context.Context, in *MsgFindIn, opts ...grpc.CallOption) (*InboxGetOut, error)
	InboxGet(ctx context.Context, in *MsgGetIn, opts ...grpc.CallOption) (*InboxGetOut, error)
	InboxRegister(ctx context.Context, in *InboxRegisterIn, opts ...grpc.CallOption) (*InboxRegisterOut, error)
	OutboxDelete(ctx context.Context, in *MsgDeleteIn, opts ...grpc.CallOption) (*MsgDeleteOut, error)
	OutboxFind(ctx context.Context, in *MsgFindIn, opts ...grpc.CallOption) (*OutboxGetOut, error)
	OutboxGet(ctx context.Context, in *MsgGetIn, opts ...grpc.CallOption) (*OutboxGetOut, error)
	OutboxRegister(ctx context.Context, in *OutboxRegisterIn, opts ...grpc.CallOption) (*OutboxRegisterOut, error)
	ResponseDelete(ctx context.Context, in *MsgDeleteIn, opts ...grpc.CallOption) (*MsgDeleteOut, error)
	ResponseRegister(ctx context.Context, in *ResponseRegisterIn, opts ...grpc.CallOption) (*ResponseRegisterOut, error)
	TargetDelete(ctx context.Context, in *MsgDeleteIn, opts ...grpc.CallOption) (*MsgDeleteOut, error)
	TargetRegister(ctx context.Context, in *TargetRegisterIn, opts ...grpc.CallOption) (*TargetRegisterOut, error)
}

type flowClient struct {
	cc grpc.ClientConnInterface
}

func NewFlowClient(cc grpc.ClientConnInterface) FlowClient {
	return &flowClient{cc}
}

func (c *flowClient) InboxDelete(ctx context.Context, in *MsgDeleteIn, opts ...grpc.CallOption) (*MsgDeleteOut, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgDeleteOut)
	err := c.cc.Invoke(ctx, Flow_InboxDelete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) InboxFind(ctx context.Context, in *MsgFindIn, opts ...grpc.CallOption) (*InboxGetOut, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InboxGetOut)
	err := c.cc.Invoke(ctx, Flow_InboxFind_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) InboxGet(ctx context.Context, in *MsgGetIn, opts ...grpc.CallOption) (*InboxGetOut, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InboxGetOut)
	err := c.cc.Invoke(ctx, Flow_InboxGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) InboxRegister(ctx context.Context, in *InboxRegisterIn, opts ...grpc.CallOption) (*InboxRegisterOut, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InboxRegisterOut)
	err := c.cc.Invoke(ctx, Flow_InboxRegister_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) OutboxDelete(ctx context.Context, in *MsgDeleteIn, opts ...grpc.CallOption) (*MsgDeleteOut, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgDeleteOut)
	err := c.cc.Invoke(ctx, Flow_OutboxDelete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) OutboxFind(ctx context.Context, in *MsgFindIn, opts ...grpc.CallOption) (*OutboxGetOut, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OutboxGetOut)
	err := c.cc.Invoke(ctx, Flow_OutboxFind_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) OutboxGet(ctx context.Context, in *MsgGetIn, opts ...grpc.CallOption) (*OutboxGetOut, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OutboxGetOut)
	err := c.cc.Invoke(ctx, Flow_OutboxGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) OutboxRegister(ctx context.Context, in *OutboxRegisterIn, opts ...grpc.CallOption) (*OutboxRegisterOut, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OutboxRegisterOut)
	err := c.cc.Invoke(ctx, Flow_OutboxRegister_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) ResponseDelete(ctx context.Context, in *MsgDeleteIn, opts ...grpc.CallOption) (*MsgDeleteOut, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgDeleteOut)
	err := c.cc.Invoke(ctx, Flow_ResponseDelete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) ResponseRegister(ctx context.Context, in *ResponseRegisterIn, opts ...grpc.CallOption) (*ResponseRegisterOut, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResponseRegisterOut)
	err := c.cc.Invoke(ctx, Flow_ResponseRegister_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) TargetDelete(ctx context.Context, in *MsgDeleteIn, opts ...grpc.CallOption) (*MsgDeleteOut, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgDeleteOut)
	err := c.cc.Invoke(ctx, Flow_TargetDelete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) TargetRegister(ctx context.Context, in *TargetRegisterIn, opts ...grpc.CallOption) (*TargetRegisterOut, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TargetRegisterOut)
	err := c.cc.Invoke(ctx, Flow_TargetRegister_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FlowServer is the server API for Flow service.
// All implementations must embed UnimplementedFlowServer
// for forward compatibility.
type FlowServer interface {
	InboxDelete(context.Context, *MsgDeleteIn) (*MsgDeleteOut, error)
	InboxFind(context.Context, *MsgFindIn) (*InboxGetOut, error)
	InboxGet(context.Context, *MsgGetIn) (*InboxGetOut, error)
	InboxRegister(context.Context, *InboxRegisterIn) (*InboxRegisterOut, error)
	OutboxDelete(context.Context, *MsgDeleteIn) (*MsgDeleteOut, error)
	OutboxFind(context.Context, *MsgFindIn) (*OutboxGetOut, error)
	OutboxGet(context.Context, *MsgGetIn) (*OutboxGetOut, error)
	OutboxRegister(context.Context, *OutboxRegisterIn) (*OutboxRegisterOut, error)
	ResponseDelete(context.Context, *MsgDeleteIn) (*MsgDeleteOut, error)
	ResponseRegister(context.Context, *ResponseRegisterIn) (*ResponseRegisterOut, error)
	TargetDelete(context.Context, *MsgDeleteIn) (*MsgDeleteOut, error)
	TargetRegister(context.Context, *TargetRegisterIn) (*TargetRegisterOut, error)
	mustEmbedUnimplementedFlowServer()
}

// UnimplementedFlowServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFlowServer struct{}

func (UnimplementedFlowServer) InboxDelete(context.Context, *MsgDeleteIn) (*MsgDeleteOut, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InboxDelete not implemented")
}
func (UnimplementedFlowServer) InboxFind(context.Context, *MsgFindIn) (*InboxGetOut, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InboxFind not implemented")
}
func (UnimplementedFlowServer) InboxGet(context.Context, *MsgGetIn) (*InboxGetOut, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InboxGet not implemented")
}
func (UnimplementedFlowServer) InboxRegister(context.Context, *InboxRegisterIn) (*InboxRegisterOut, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InboxRegister not implemented")
}
func (UnimplementedFlowServer) OutboxDelete(context.Context, *MsgDeleteIn) (*MsgDeleteOut, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OutboxDelete not implemented")
}
func (UnimplementedFlowServer) OutboxFind(context.Context, *MsgFindIn) (*OutboxGetOut, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OutboxFind not implemented")
}
func (UnimplementedFlowServer) OutboxGet(context.Context, *MsgGetIn) (*OutboxGetOut, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OutboxGet not implemented")
}
func (UnimplementedFlowServer) OutboxRegister(context.Context, *OutboxRegisterIn) (*OutboxRegisterOut, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OutboxRegister not implemented")
}
func (UnimplementedFlowServer) ResponseDelete(context.Context, *MsgDeleteIn) (*MsgDeleteOut, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResponseDelete not implemented")
}
func (UnimplementedFlowServer) ResponseRegister(context.Context, *ResponseRegisterIn) (*ResponseRegisterOut, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResponseRegister not implemented")
}
func (UnimplementedFlowServer) TargetDelete(context.Context, *MsgDeleteIn) (*MsgDeleteOut, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TargetDelete not implemented")
}
func (UnimplementedFlowServer) TargetRegister(context.Context, *TargetRegisterIn) (*TargetRegisterOut, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TargetRegister not implemented")
}
func (UnimplementedFlowServer) mustEmbedUnimplementedFlowServer() {}
func (UnimplementedFlowServer) testEmbeddedByValue()              {}

// UnsafeFlowServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FlowServer will
// result in compilation errors.
type UnsafeFlowServer interface {
	mustEmbedUnimplementedFlowServer()
}

func RegisterFlowServer(s grpc.ServiceRegistrar, srv FlowServer) {
	// If the following call pancis, it indicates UnimplementedFlowServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Flow_ServiceDesc, srv)
}

func _Flow_InboxDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDeleteIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).InboxDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_InboxDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).InboxDelete(ctx, req.(*MsgDeleteIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_InboxFind_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgFindIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).InboxFind(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_InboxFind_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).InboxFind(ctx, req.(*MsgFindIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_InboxGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgGetIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).InboxGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_InboxGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).InboxGet(ctx, req.(*MsgGetIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_InboxRegister_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InboxRegisterIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).InboxRegister(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_InboxRegister_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).InboxRegister(ctx, req.(*InboxRegisterIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_OutboxDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDeleteIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).OutboxDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_OutboxDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).OutboxDelete(ctx, req.(*MsgDeleteIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_OutboxFind_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgFindIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).OutboxFind(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_OutboxFind_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).OutboxFind(ctx, req.(*MsgFindIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_OutboxGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgGetIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).OutboxGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_OutboxGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).OutboxGet(ctx, req.(*MsgGetIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_OutboxRegister_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OutboxRegisterIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).OutboxRegister(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_OutboxRegister_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).OutboxRegister(ctx, req.(*OutboxRegisterIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_ResponseDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDeleteIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).ResponseDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_ResponseDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).ResponseDelete(ctx, req.(*MsgDeleteIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_ResponseRegister_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResponseRegisterIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).ResponseRegister(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_ResponseRegister_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).ResponseRegister(ctx, req.(*ResponseRegisterIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_TargetDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDeleteIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).TargetDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_TargetDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).TargetDelete(ctx, req.(*MsgDeleteIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_TargetRegister_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TargetRegisterIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).TargetRegister(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_TargetRegister_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).TargetRegister(ctx, req.(*TargetRegisterIn))
	}
	return interceptor(ctx, in, info, handler)
}

// Flow_ServiceDesc is the grpc.ServiceDesc for Flow service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Flow_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "kontrl.Flow",
	HandlerType: (*FlowServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InboxDelete",
			Handler:    _Flow_InboxDelete_Handler,
		},
		{
			MethodName: "InboxFind",
			Handler:    _Flow_InboxFind_Handler,
		},
		{
			MethodName: "InboxGet",
			Handler:    _Flow_InboxGet_Handler,
		},
		{
			MethodName: "InboxRegister",
			Handler:    _Flow_InboxRegister_Handler,
		},
		{
			MethodName: "OutboxDelete",
			Handler:    _Flow_OutboxDelete_Handler,
		},
		{
			MethodName: "OutboxFind",
			Handler:    _Flow_OutboxFind_Handler,
		},
		{
			MethodName: "OutboxGet",
			Handler:    _Flow_OutboxGet_Handler,
		},
		{
			MethodName: "OutboxRegister",
			Handler:    _Flow_OutboxRegister_Handler,
		},
		{
			MethodName: "ResponseDelete",
			Handler:    _Flow_ResponseDelete_Handler,
		},
		{
			MethodName: "ResponseRegister",
			Handler:    _Flow_ResponseRegister_Handler,
		},
		{
			MethodName: "TargetDelete",
			Handler:    _Flow_TargetDelete_Handler,
		},
		{
			MethodName: "TargetRegister",
			Handler:    _Flow_TargetRegister_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "flow_service/flow_service.proto",
}
